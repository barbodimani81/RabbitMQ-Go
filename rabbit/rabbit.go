package rabbit

import (
	"fmt"
	"log"
	"time"

	mq "github.com/rabbitmq/amqp091-go"
)

// TODO: complete the ags for the methods
type MessageQueue interface {
	Publish(queueName string, message string)
	Consume(exchangeName string)
}

type RabbitMQClient struct {
	conn    *mq.Connection
	channel *mq.Channel
}

func NewRabbitMQClient(url string) (*RabbitMQClient, error) {
	var conn *mq.Connection
	var err error
	backoff := 1 * time.Second

	for retries := 0; retries < 5; retries++ {
		conn, err = mq.Dial(url)
		if err == nil {
			break
		}
		log.Printf("Failed to connect to RabbitMQ, retrying in %s... (attempt %d/5)", backoff, retries+1)
		time.Sleep(backoff)
		backoff *= 2
	}

	if err != nil {
		return nil, fmt.Errorf("could not connect to RabbitMQ after 5 attempts: %w", err)
	}

	channel, err := conn.Channel()
	if err != nil {
		return nil, fmt.Errorf("failed to open channel: %w", err)
	}

	return &RabbitMQClient{
		conn:    conn,
		channel: channel,
	}, nil
}

func (r *RabbitMQClient) Publish(exchangeName string, message string) error {
	// Declare a durable exchange (survives RabbitMQ restarts)
	err := r.channel.ExchangeDeclare(
		exchangeName, // Exchange name
		"fanout",     // Exchange type (fanout in this case)
		true,         // Durable (survives restarts)
		false,        // Auto-deleted (false means it won't be deleted when not in use)
		false,        // Internal
		false,        // No-wait
		nil,          // Arguments
	)
	if err != nil {
		return err
	}

	// Publish a persistent message
	err = r.channel.Publish(
		exchangeName, // Exchange name
		"",           // Routing key (not used for fanout)
		false,        // Mandatory
		false,        // Immediate
		mq.Publishing{
			ContentType:  "text/plain",    // Message content type
			DeliveryMode: mq.Persistent,   // Persistent message
			Body:         []byte(message), // Message body
		},
	)
	return err
}

func (r *RabbitMQClient) Consume(exchangeName string) (<-chan mq.Delivery, error) {
	// Declare a durable exchange (survives RabbitMQ restarts)
	err := r.channel.ExchangeDeclare(
		exchangeName, // Exchange name
		"fanout",     // Exchange type (fanout)
		true,         // Durable (survives restarts)
		false,        // Auto-deleted (false means it won't be deleted when not in use)
		false,        // Internal
		false,        // No-wait
		nil,          // Arguments
	)
	if err != nil {
		return nil, err
	}

	// Declare a durable, non-exclusive queue
	queue, err := r.channel.QueueDeclare(
		"",    // Name (empty means RabbitMQ generates a unique name)
		true,  // Durable (queue survives restarts)
		true,  // Auto-delete (queue will be deleted when no consumers are attached)
		false, // Exclusive (queue is not exclusive to the connection)
		false, // No-wait
		nil,   // Arguments
	)
	if err != nil {
		return nil, err
	}

	// Bind the queue to the fanout exchange
	err = r.channel.QueueBind(
		queue.Name,   // Queue name
		"",           // Routing key (not used for fanout)
		exchangeName, // Exchange name
		false,        // No-wait
		nil,          // Arguments
	)
	if err != nil {
		return nil, err
	}

	// Start consuming from the queue
	msgs, err := r.channel.Consume(
		queue.Name, // Queue name
		"",         // Consumer tag (empty means autogenerated)
		true,       // Auto-acknowledge
		false,      // Exclusive
		false,      // No-local
		false,      // No-wait
		nil,        // Arguments
	)
	return msgs, err
}

// Close gracefully shuts down the RabbitMQ connection and channel.
func (r *RabbitMQClient) Close() {
	// Close the channel and connection
	r.channel.Close()
	r.conn.Close()
}
